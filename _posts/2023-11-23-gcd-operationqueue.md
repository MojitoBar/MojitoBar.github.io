---
title: GCD와 OperationQueue의 차이점
author: mojitobar
date: 2023-11-23 01:37:00 +0900
categories: [iOS, Swift]
tags: [iOS, Swift, GCD, OperationQueue]
comments: true
---

## GCD와 OperationQueue의 차이점

Grand Central Dispatch (GCD)와 OperationQueue는 iOS에서 비동기 작업을 처리하는 두 가지 주요 방법입니다.

이번에는 각각의 특징과 차이점을 알아봤습니다.

1. **Grand Central Dispatch (GCD)**
   - **저수준 API**: GCD는 C 기반의 저수준 API로, Swift나 Objective-C에서 사용할 수 있습니다.
   - **디스패치 큐**: 작업을 디스패치 큐에 추가하며, 이 큐들은 First-In-First-Out(FIFO) 순서로 작업을 처리합니다.
   - **컨커런시 관리**: GCD는 시스템에 의해 관리되는 컨커런트 큐를 제공하여 멀티코어 프로세싱을 최적화합니다.
   - **간결성**: GCD는 작업 실행을 위한 간단하고 강력한 방법을 제공합니다. **`async`**와 **`sync`** 함수를 사용하여 큐에 작업을 추가할 수 있습니다.
   - **사용 용이성**: 일반적인 병렬 작업과 백그라운드 작업에 적합하며, 코드 구현이 비교적 단순합니다.
2. **OperationQueue**
   - **고수준 API**: OperationQueue는 Swift와 Objective-C에서 사용되는 고수준 API입니다.
   - **작업 종속성**: OperationQueue를 사용하면 작업(Operations) 간의 종속성을 설정할 수 있습니다. 예를 들어, 하나의 작업이 완료된 후 다른 작업을 시작하도록 구성할 수 있습니다.
   - **취소 및 일시 중지**: OperationQueue를 사용하면 실행 중인 작업을 취소하거나 큐를 일시 중지할 수 있는 기능이 제공됩니다.
   - **커스터마이징**: Operation을 서브클래싱하여 복잡한 비동기 패턴을 구현할 수 있으며, 작업의 실행 상태를 더 세밀하게 제어할 수 있습니다.
   - **적응성**: 복잡한 비동기 작업이나 서로 다른 작업 간의 의존성이 중요한 경우에 적합합니다.

### **차이점 요약**

- **수준의 차이**: GCD는 저수준 API이며, OperationQueue는 고수준 API입니다.
- **종속성 및 제어**: OperationQueue는 작업 간의 종속성 설정 및 작업 취소, 일시 중지 기능을 제공합니다. GCD는 이러한 기능을 직접적으로 제공하지 않습니다.
- **구현의 복잡성**: GCD는 구현이 간단하고 직관적입니다. 반면, OperationQueue는 더 많은 기능을 제공하지만 구현이 복잡해질 수 있습니다.
- **사용 사례**: GCD는 간단한 병렬 처리 및 백그라운드 작업에 적합하고, OperationQueue는 복잡한 작업 흐름과 의존성이 필요한 경우 유용합니다.

개발자로서 어떤 도구를 선택할지는 개발하고자 하는 애플리케이션의 특성과 요구 사항에 따라 달라질 수 있습니다. GCD는 일반적인 경우에 적합하며, 더 복잡한 시나리오에서는 OperationQueue의 추가적인 기능이 유리할 수 있습니다.

## 복잡한 비동기 패턴이 뭘까?

OperationQueue는 GCD에 비해 복잡한 비동기 패턴을 구현할 수 있다고 했습니다.

복잡한 비동기 패턴의 예시에는 무엇이 있을까요?

OperationQueue를 사용하여 구현할 수 있는 복잡한 비동기 패턴에는 여러 가지가 있습니다. 이러한 패턴은 주로 작업 간의 의존성, 우선순위, 상태 관리 등 복잡한 동시성 관리가 필요한 상황에서 유용합니다. 여기 몇 가지 예시를 들어보겠습니다

1. **의존성이 있는 작업 시퀀스**
   - 특정 작업이 다른 작업들의 완료에 의존하는 경우, 예를 들어 데이터를 다운로드한 후 그 데이터를 처리하고, 그 후에 UI를 업데이트하는 시나리오에서, OperationQueue를 사용하면 이러한 의존성을 명확하게 정의할 수 있습니다.
   - OperationQueue는 **`addDependency`** 메소드를 사용하여 작업 간의 의존성을 쉽게 설정할 수 있게 해줍니다.
2. **동시에 실행되는 작업 수 제한**
   - 동시에 너무 많은 네트워크 요청이나 계산 집약적 작업이 실행되는 것을 방지하기 위해, OperationQueue의 **`maxConcurrentOperationCount`**를 설정하여 동시에 실행되는 작업의 수를 제한할 수 있습니다.
3. **작업 취소 및 일시 중지**
   - OperationQueue는 진행 중인 작업을 취소하거나 일시 중지하고 재개하는 기능을 제공합니다. 이는 사용자의 입력에 반응하거나, 앱의 상태 변화에 따라 작업을 조절해야 할 때 유용합니다.
4. **복잡한 오류 처리**
   - 여러 작업이 연쇄적으로 이루어지는 과정에서 발생할 수 있는 오류를 관리하고 처리하는 데 있어, OperationQueue는 각 Operation의 상태를 모니터링하고, 성공 또는 실패에 따라 추가적인 로직을 실행할 수 있는 유연성을 제공합니다.
5. **우선순위 기반 작업 관리**
   - 다양한 작업에 우선순위를 부여하여 중요한 작업이 먼저 실행되도록 할 수 있습니다. 예를 들어, 사용자 인터페이스와 관련된 작업을 더 높은 우선순위로 설정하여 빠른 반응성을 보장할 수 있습니다.

이러한 복잡한 비동기 패턴들은 OperationQueue의 고수준 API를 통해 구현할 수 있으며, GCD를 사용할 때보다 더 세밀한 제어가 가능합니다. 이런 특징들은 애플리케이션의 특정 요구 사항에 따라 OperationQueue를 선택하는 중요한 이유가 됩니다.

## 어떤 것이 먼저 개발되었을까?

Grand Central Dispatch (GCD)와 OperationQueue 중에서, OperationQueue가 먼저 개발되었습니다.

1. **OperationQueue**:
   - OperationQueue (당시에는 NSOperationQueue로 알려짐)는 Objective-C 기반의 Cocoa 프레임워크에 속해 있었으며, iOS 2.0과 함께 2008년에 도입되었습니다.
   - 이는 고수준의 추상화를 제공하여, 작업의 의존성 관리 및 실행을 용이하게 만들었습니다.
2. **Grand Central Dispatch (GCD)**:
   - GCD는 나중에 iOS 4.0에서 2010년에 도입되었습니다.
   - 이는 Apple이 개발한 저수준 동시성 및 병렬처리를 위한 기술로, C 기반의 API를 제공합니다.
   - GCD의 목적은 멀티코어 하드웨어의 성능을 최대로 활용하는 것이었으며, 이를 위해 디스패치 큐라는 개념을 도입했습니다.

> 그냥 막연하게 생각했을 땐 저수준 API가 먼저 개발되고 고수준 API가 개발되었을 것 같았습니다.
>
> 왜냐하면 GCD에서 제공하는 기능들이 OperationQueue에서 이미 제공되고 있던 것이기 때문입니다.
>
> 왜 이후에 GCD를 추가하게 되었을까요?

### GCD의 도입 목적

- GCD는 멀티코어 프로세서의 효율적 사용에 초점을 맞추고 있습니다. 이는 저수준 C 기반 API로, 시스템 수준의 최적화를 제공하여 멀티스레딩을 더 쉽고 효율적으로 만듭니다.
- GCD는 디스패치 큐를 사용하여 작업을 관리하며, 이는 FIFO(First-In-First-Out) 방식으로 작업을 처리합니다. 이는 간단하고 가벼운 병렬 처리 및 비동기 작업에 이상적입니다.
- 또한, GCD는 다양한 유형의 큐(메인, 글로벌, 커스텀)를 제공하여 다양한 수준의 동시성을 쉽게 구현할 수 있도록 합니다.

## 마무리

GCD와 OperationQueue는 모두 비동기 작업을 처리하는 데 사용되는 도구입니다. 이 두 가지 방법은 각각의 특징과 장단점을 가지고 있으며, 애플리케이션의 특성과 요구 사항에 따라 선택되어야 합니다.

GCD는 저수준 API로, 간단하고 가벼운 비동기 작업을 처리하는 데 적합합니다. 반면, OperationQueue는 고수준 API로, 복잡한 비동기 작업을 처리하는 데 적합합니다.

GCD는 기존의 OperationQueue보다 멀티스레딩을 더 쉽고 효율적으로 개발하기위해 나중에 도입된 기술입니다.
